---
title: '18v'
date: 2022-03-18 16:21:13
category: 'react'
draft: false
---

useTransition
Suspense and SSR
Automatic Batching

\*useTransition
구 버전의 경우 한번 렌더링연산이 시작되면 멈출 수 없으며(블로킹 렌더링),

그로인해 리소스가 많거나 업데이트가 많은 화면의 경우 렌더링이 될때 의도치 않은 지연현상이 발생을 배경으로 등장하였다.

/\*\*

- @타노스: 18v useTransiton test before
  \*/

import { useState } from "react";
import "./styles.css";

export default function App() {
const [searchValue, setSearchValue] = useState(0);

const renderBox = Array.from({ length: searchValue \* 100 }, (v, i) => i);

const onChangeSearch = ({ target }) => {
setSearchValue(target.value.length);
};

return (
<div className="App">
<div>
<input type="text" onChange={onChangeSearch} />
</div>

      {renderBox.map((x) => {
        return <div className="box" key={x + "box"}></div>;
      })}
    </div>

);
}
위의 코드를 바탕으로 한 화면구현에서 인풋창을 보게되면 무수히많은 렌더링연산으로 인풋입력 속도가 매우 느리게 진행되고 있다.

/\*\*

- @타노스: 18v useTransiton test after
  \*/

import { useTransition, useState } from "react";
import "./styles.css";

export default function App() {
const [isPending, startTransition] = useTransition();
const [searchValue, setSearchValue] = useState(0);

const renderBox = Array.from({ length: searchValue \* 100 }, (v, i) => i);

const onChangeSearch = ({ target }) => {
startTransition(() => {
setSearchValue(target.value.length);
});
};

return (
<div className="App">
<div>
<input type="text" onChange={onChangeSearch} />
</div>
{isPending && <h2>isPending..</h2>}
{renderBox.map((x) => {
return <div className="box" key={x + "key"}></div>;
})}
</div>
);
}
인풋 입력속도가 상당히 개선된 것을 확인할 수 있으며 isPending을 통해 로딩 플래그 또한 걸 수 있다.

근데.. debounce와 throttle로 개선할수 있는 문제가 아닌가?

사실 useTransition, debounce, throttle는 사용목적이 다르다고 한다.

debounce는 사용자의 행위 이후에 업데이트 진행

그렇기 때문에 사용자행위가 길어질수록 업데이트가 지연된다.

throttle은 입력주기를 미리 지정해 입력주기에 도달하면 업데이트를 우선순위로 둔다.

하지만 입력주기가 되기전 사용자행위를 멈춘다면 지연시간을 경험한다.

useTransition은 우선순위를 사용자가 지정합니다.

위에서 코딩한 예제와 같이 우리는 startTransition에 사용자 행위에 대한 우선순위를 높이고 렌더에 우선순위를 미뤄 개선 했었습니다.

18v에서 개선된 렌더링 도중에도 우선순위가 높은 작업을 처리할 수 있는 기능향상점

\*Suspense and SSR
Suspense는 어떤 컴포넌트가 읽어야 하는 데이터가 아직 준비가 되지 않았다고 리액트에게 알려주는 새로운 매커니즘 이것을 SSR에 이용한다.

먼저 CSR과 SSR을 비교해 봐야 할텐데요

CSR(Client Side Rendering)은 위의 그림과 같이 2단계에서 바로 볼 수 없습니다. 마지막 4단계에서 볼 수 있으며, 상호작용 할 수 있는 것입니다.

그 이유는 서버가 HTML 파일을 줄 때, 렌더가 준비가 된 파일이 아니기 때문입니다.

즉, HTML 파일 안에는 아무런 내용이 없다는 것입니다. 그 내용은 JS 파일을 받아 실행을 시켜야 그제서야 만들어지는 것입니다.

이후, 브라우저가 추가적으로 JS 파일을 다운받고 실행하면 이후 렌더링, 그려주게 되는 것입니다.

서버에서 렌더 될 준비를 끝마친 상태로 HTML 응답을 브라우저(클라이언트)에 보내는 것입니다.

브라우저에서 말하는 렌더링의 의미는 HTML, CSS, JavaScript 파일을 받아와 이를 읽고 파싱해서 실행한 결과물로 화면에 그려내는 과정입니다.

그러나 서버 사이드 렌더링에서 의미를 따지자면, HTML 파일 내에 내용이 있느냐 없느냐입니다. 내용이 있다면, 렌더링이 된 것입니다.

이렇게 HTML 파일 내에 내용이 모두 있으므로 브라우저는 바로 페이지를 렌더링합니다. 그리고 사용자에게 바로 보여지는 것입니다.

이후 브라우저는 자바스크립트 파일을 다운 받습니다. 이후 4단계 자바스크립트가 html과 css 상호작용하는(Hydrate)가 일어납니다.

우리가 기억해야할 부분은 페이지가 보여지는 것은 2단계에서 가능했다는 것.

그렇다면 18v에서의 suspense는 무엇을 위해?

기존 리액트에서의 SSR 구조는 다음과 같다. (like waterfall) 서버가 리액트 코드 가져옴 → HTML로 만듦 → 리액트가 HTML 받음 → hydrate (자바스크립트 붙이는 작업)
모든 데이터를 불러오고, html로 만들고 또 이걸 리액트로 내려보내야 하기 때문에 어느 지점에서 병목현상이 일어나면 (한없이) 느려지게 된다.

18v부터 HTML 스트리밍 API와 Suspense를 연계해 SSR을 설계할 수 있다.

// 여기서는 createRoot 가 아니라 hydrateRoot를 사용한다.
<Layout>
<NavBar />
<Sidebar />
<RightPane>
<Post />
<Suspense fallback={<Spinner />}>
<Comments />
</Suspense>
</RightPane>
</Layout>
서버에서는 renderToString 대신, pipeToNodeWritable로 HTML을 클라이언트로 스트리밍하고, Suspense로 선택적 hydration을 진행한다. pipeToNodeWritable 자세히 알아보기

pipeToNodeWritable를 사용하면 Suspense로 감싸진 이외의 다른 HTML 파일들은 즉시 스트리밍되며 렌더링된다.

그 후 Comments 컴포넌트가 서버에서 렌더링되며 끝나게 된다. (렌더링 동안은 fallback이 렌더링 된다.)

Lazy 컴포넌트도 이제 서버 사이드가 가능해지면서, 코드 스플리팅도 지원된다. (lodable 처리가 필요없게 되었음)

더 엄청난건, Suspense가 두개 이상 있을 때 나타난다.

// 일단 이미 서버로부터 HTML을 다 받았고, Suspense로 감싼 부분에 hydration은 아직 되지 않은 상태라고 가정
<Layout>
<NavBar />
// hydration 중
<Suspense fallback={<Spinner />}>
<Sidebar />
</Suspense>
<RightPane>
<Post />
// hydration 중
<Suspense fallback={<Spinner />}>
<Comments />
</Suspense>
</RightPane>
</Layout>
hydration은 동시에 일어나는게 아니라 비동기로 일어나는데, 위에서부터 순서대로 발견된 Suspense부터 처리한다.

그런데 만약 유저가 댓글을 너무 빨리 달고 싶어 댓글을 먼저 클릭한다면, 리액트는 이를 알아차리고 Comments부터 hydration을 처리한다.(유동적으로 hydrate 우선순위를 판단)

Suspense가 어떻게 서버 요청을 기다리는지는 리액트가 알아서 판단한다.

axios나 fetch같은 AJAX 통신을 자기가 알아서 파악하고 fallback을 출력한다.

\*automatic Batching
먼저 Batching이란?

여러개의 state 업데이트를 하나의 Renderer가 발생하도록 그룹화 하는 것.

물론 이전 버전에서도 batching을 지원했지만 이벤트 핸들러 내부에 발생하는 업데이트에 한정 했었다.

// 17v은 2번 리렌더링, 18v부터는 1번 리렌더링.
function App () {
const [number, setNumber] = useState(0);
const [toggle, setToggle] = useState(false);

    function onClickToggle () {
        fetchSomething().then(() => {
            setNumber(prev => prev + 1);
            setToggle(prev => !prev);
        });
    }

    return <button onClick={onClickToggle}>button</button>

}
이와 같이 fetch 혹은 의도적으로 시간을 지연 시키는 상황 등에서는 배칭이 적용되지 않는다.

이전 버전의 자동 배칭은 이벤트 핸들러 내부의 콜백이 모두 완료된 후에는 실행되지 않는다.

fetch의 경우 이벤트 핸들러 콜백(스택)이 호출 완료된 후 실행되는 콜백(큐)이기 때문에 해당되지 않는 것이다.

하지만 18v 자동 배칭 시스템은 기존 콜스택에서 태스크 큐까지로 범위를 넓혔다.

// 하지만 이런 상황은 두번 리렌더링 된다. 모든걸 한번에 리렌더 하는게 아니고 테스크 큐까지로만 확대한 것이기 때문
function onClickToggle () {
setNumber(prev => prev + 1);
fetchSomething().then(() => {
setToggle(prev => !prev);
});
}
물론 배칭을 하고 싶지 않을 경우 flushSync()를 사용하면 막을 수 있는 장치가 되어있다.

import { flushSync } from "react-dom";

function onClickToggle() {
flushSync(() => {
setNumber(prev => prev + 1);
});

flushSync(() => {
setToggle(prev => !prev);
});
}
