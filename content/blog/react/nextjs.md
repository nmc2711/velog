---
title: 'Next JS BASIC CONCEPT'
date: 2021-02-03 18:21:13
category: 'react'
draft: false
---

## NEXT JS를 쓰는 이유와 기본 컨셉들을 정리해 보자

- 공식문서 : https://nextjs.org/learn/basics/create-nextjs-app

<br />

먼저, 서버사이드 렌더링 과 클라이언트사이드 렌더링에 대해 짚고 넘어가자 !

<br />

Next.js에 공부하게되면 항상 나오는 토픽은 SSR과 CSR 방식이다. <br />
주된 목적으로 React환경에서 `서버사이드 렌더링`을 구현하기 위해 만들어진 프레임워크이기 때문이다. <br />

기존의 전통적인 서버사이드렌더링 환경에서는 페이지에 대한 요청이 들어오면, <br />
서버에서 렌더링을 마치고 데이터와 결합된 완성된 정적 HTML 파일을 내려준다. <br />
클라이언트가 `다른 페이지에서 요청` 한다면 서버에선 또 다시 새로운 HTML파일을 생성하고, 다시 클라이언트에 내려줄 것이다.<br />
이러한 사이클이 서버 사이드 렌더랑이라고 할 수 있다. <br />
서버사이드렌더링은 각 페이지에 접근할 때마다 페이지 전체에 대한 리로드가 발생하면서 `매번 페이지가 갱신`되기 떄문에 비효율적이지만, <br />
페이지가 처음 그려질때부터 `완성된 HTML로 넘어오기 때문에 크롤링을 고려한 SEO에서는 강점`이 있다. <br />

`클라이언트 사이드 렌더링`은 서버에서는 `페이지를 구성하기 위한 최소한의 리소스만 전달`하고, `클라이언트에서 페이지의 컨텐츠를 구성`하는 방식이라고 할 수 있다.<br />
클라이언트 사이드 렌더링에서는 초기 렌더링 시에 필요한 리소스를 모두 내려받고 나면, 그 이후로는 사용자가 접근한 페이지들에서 요청하는 일부 데이터만을 요청한다. <br />
그렇기 때문에 초기 `로딩 속도는 비교적 느릴수 있지만, 불필요한 페이지 갱신과 데이터 요청을 줄일 수있다는 장점`이 있다. <br />

최근의 웹 트렌드는 클라이언트 사이드를 기반으로한 싱글페이지 어플리케이션이라고 들어 봤을 것이다. <br />
리액트나 뷰를 이용해 자바스트립가 어플리케이션을 구성하는 데 핵심적인 역활을 담당하고, 번들된 자바스크립트 소스의 실행을 통해 페이지를 구성하는 방식이 많아졌다. <br />
SPA는 기본적으로 단일 페이지로 구성되며, 초기 렌더링 시에 페이지에 필요한 리소스를 내려받은 다음부터는 사용자에게 필요한 화면만을 갱신한다<br />

반면, SPA의 단점은 SEO(검색엔진 최적화) 측면에서 문제가 생긴다는 것이다. 웹에서 많은 크롤러들이 자바스크립트를 지원하지 않기 때문에 크롤링 단계에서 화면에는 빈 HTML만 보여질 수 있다. <br />
물론 구글 봇 같은 경우에는 자바스크립트를 지원하기 때문에 CSR을 통한 화면도 SEO에 불이익을 받지 않을 수 있다. <br />

#### NEXT JS의 특징

NEXT JS는 `클라이언트 사이드 렌더링에서 발생하는 여러 문제`들을 해결하고, REACT 개발환경에서 SSR을 구현할 수 있도록 도와준다.<br />

- 자바스크립트 코드를 번들링 하기 위해 웹팩등의 모듈 번들러를 사용하지만, 그렇게 생성된 자바스크립트 번들은 용량이 크고 그만큼의 로딩시간이 걸린다. (최적화를 위해 코드 스플릿팅 처리가 필요)
- SEO를 고려하기 위해 자바스크립트 소스를 렌더링하기 전 정적 소스를 먼저 불러와야 할 경우가 있다.

위의 문제해결을 필두로 NEXT JS는 여러기능을 내장했다. 자체 렌더링 서버를 먼저 실행하여 렌더링 단계에서 먼저 실행되어야 하는 로직을 수행한 다음 클라이언트트 로직을 수행한다. <br />
최초 서버에 요청이 들어왔을때, 서버에서는 요청이 들어온 페이지에 들어갈 데이터를 FETCH하고 구성된 HTML을 클라이언트로 보내주는 방식이다. <br />

- 직관적인 페이지 기반 라우팅 시스템 (다이나믹 라우팅)
- PRE-RENDERING, STATIC GENERATION(SSG)와 SSR을 페이지 단위로 각각 구성할 수 있다.
- 빠른 페이지 로딩을 위해 자동적인 코드 스플리팅을 지원한다.
- 최적화된 PRE-FETCHING으로 클라이언트 사이드 렌더링 역시 구현할 수 있다.

( `다이나믹 라우팅?` 라우트의 경로에 특정 값을 넣어 해당 페이지로 이동할 수 있게 하는 기법. 동적으로 변경되는 정보는 URL파라미터 혹은 쿼리파라미터로 전달 할 수 있다.) <br />

#### NEXT JS의 특징을 파해쳐 보자

`PRE-RENDERING` : NEXT JS는 렌더링 서버를 자체적으로 지원하고, 기본적으로 모든페이지를 PRE-RENDER한다. 클라이언트 사이드에서 모든 작업을 수행하는 대신 미리 각페이지 대한 <br />
HTML 뼈대 파일을 미리 만들어 성능과 SEO 측면에서 도움을 준다. 예를 들어 NEXT JS로 구성된 웹페이지의 개발자도구에서(ctrl+ shift + p -> disable javascript)를 하여도 <br />
HTML 뼈대가 렌더 되는것을 볼 수 있다. 또한 getStaticProps, getStaticPaths 내장함수를 이용해 FETCH한 데이터를 미리 렌더링 서버에서 실행되어 화면이 그려지기 전에 데이터를 연동가능하다. <br />
이렇게 NEXT JS는 최소한의 자바스크립트 코드를 사용해 HTML 화면을 먼저 생성한다. 그리고 이어 자바스크립트가 로드되면, 그때 컴포넌트와 앱 화면이 완전히 활성화 된다. 이러한 과정을 `Hydration`이라고 한다<br />

`Hybrid - SSG and SSR` : NEXT JS는 두 가지 형태의 프리 렌더링을 지원한다. 정적 생성(Static Generation - SSG)과 서버 사이드 렌더링(SSR)이다. <br />
NEXT JS에서는 성능상의 이유로 SSG 추천하지만, 각 페이지마다 어떤 종류를 택할지 선택할 수 있다. <br />

- SSG: 빌드 시점에서 HTML 파일이 생성되며, 매 요청마다 재사용 된다. CDN으로 캐싱되어 사용할 수 있다.
- SSR: HTML이 request에 따라 생성된다. 최신화된 데이터를 사용하거나 사용자 요청에 따라 데이터를 받아와야 하는 페이지에서 사용된다.

#### NEXT JS IN DATA FETCHING

NEXT JS 에서는 프리 렌더 단계에서 data fetching을 위해 3가지 함수를 지원한다. <br />

- getStaticProps: 빌드 타임에 데이터 요청
- getServerSideProps: 매 요청에 따라 데이터 요청
- getStaticPaths: 요청된 데이터에 의한 다이나믹 라우팅을 명시

1. getStaticProps: 각 페이지에서 async 함수로 getStaticProps가 export 되면, NEXT 서버는 빌드 시점에 이 함수를 호출하고 <br />
   리턴한 props를 이용해 페이지를 프리 렌더링 한다. getStaticProps는 props, revalidate, notFound, redirect라는 옵셔널 키를 가진 객체를 반환한다.

```typescript
import { GetStaticProps } from 'next'

export const getStaticProps: GetStaticProps = async context => {}
```
